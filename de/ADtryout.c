#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  frontUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftUltra,      sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  rightUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl12, redLed,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, encoderPort, I2C_1)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

	void walkStraight(){
//while(SensorValue[ultrain]>10){
	if ((nMotorEncoder[rightMotor]) > (abs(nMotorEncoder[leftMotor]))){
		motor[rightMotor] = 40;
		motor[leftMotor] = 63;
	}

	if (nMotorEncoder[rightMotor] < abs(nMotorEncoder[leftMotor])){
		motor[rightMotor] = 63;
		motor[leftMotor] = 40;
	}
	if (nMotorEncoder[rightMotor] == abs(nMotorEncoder[leftMotor])){
		motor[rightMotor] = 63;
		motor[leftMotor] = 63;
	}
//}
}

void delayStop (int delaytime){
	wait1Msec(delaytime);
	motor[leftMotor]=0;
	motor[rightMotor]=0;

}
void completeStop (int delaytime){
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	wait1Msec(delaytime); //this stops rabot for a delay of time
}

void turnRight(int degrees,int speed){
	//Reset encoders
				nMotorEncoder[rightMotor]=0;
				nMotorEncoder[leftMotor]=0;

				//Determine tickgoal
				//After testing it looks likefor a 90 degree right turn, motor needs 459 ticks, thus for 1 degree, it needs 51
				int tickGoal=(68* degrees)/10;

				//Perform a point turn to the left. We will use lower power values for more accuracy.
				// Use 40 for turn speed for now
				motor[leftMotor]=speed;
				motor[rightMotor]=-1*speed;
				//turn right

				//since the wheels may go at different speeds due to manufacturing tolerances etc.
				//we need to test both encoders and conrtol both motors seperately. This may result in one motor
				// going for longer than another. But they will ultimately resultin a more accurate turn.
				while(nMotorEncoder[leftMotor]<tickGoal || nMotorEncoder[rightMotor]>-1*tickGoal){
					if(nMotorEncoder[leftMotor]>tickGoal){motor[leftMotor]=0;}
					if(nMotorEncoder[rightMotor]<-1*tickGoal){motor[rightMotor]=0;}

				}

}
void turnLeft(int degrees,int speed){
	//Reset encoders
				nMotorEncoder[rightMotor]=0;
				nMotorEncoder[leftMotor]=0;

				//Determine tickgoal
				//After testing it looks likefor a 90 degree right turn, motor needs 459 ticks, thus for 1 degree, it needs 51
				int tickGoal=(60* degrees)/10;

				//Perform a point turn to the left. We will use lower power values for more accuracy.
				// Use 40 for turn speed for now
				motor[leftMotor]=-1*speed;
				motor[rightMotor]=speed;
				//turn right

				//since the wheels may go at different speeds due to manufacturing tolerances etc.
				//we need to test both encoders and conrtol both motors seperately. This may result in one motor
				// going for longer than another. But they will ultimately resultin a more accurate turn.
				while(nMotorEncoder[leftMotor]>-1*tickGoal || nMotorEncoder[rightMotor]<tickGoal){
					if(nMotorEncoder[leftMotor]<-1*tickGoal){motor[leftMotor]=0;}
					if(nMotorEncoder[rightMotor]>tickGoal){motor[rightMotor]=0;}

				}

}




task main()
{

		int comSpd = 60;
		//int comAdjSpd = 31;
		//int delaySec = 450;
		//int frontSpace = 12; //(46-30)/2
		int rightSpace = 23;

		//wait to have a full stop
		wait1Msec(2000);

		//Right motor is better to use than fwd motor because of different interferences
		while(SensorValue[rightUltra]<rightSpace){
			walkStraight();	//speed is debateable
		}
		delayStop(400);
		completeStop(1000); // have robot stop @ the middle of hallway

		//allow the robot to move a little more, position @ the center of intersection
		walkStraight();
		wait1Msec(100);
		completeStop(500);

		//make 90 turn, going to room#1 direction
		turnRight(90,60);	//turn to the room so we can almost enter. Right turn

		//allow te robot to move forward
		while(SensorValue[frontUltra]>25){
			walkStraight();
		}
		//move close to the wall, and stop, so the robot can stop on the middle of entry
		while(SensorValue[frontUltra]<25){  //when there is no space ahead
			completeStop(1000);	//???
		}

		turnRight(90,comSpd); //turn into the room 90@Rright turn
		completeStop(1000);

		//drive into the room
		while(SensorValue[frontUltra]>30){
			walkStraight();  //Walk straight
		}
		//stop close to 30cm
				completeStop(1000);


		//180 degree turn right
		turnRight(180,comSpd);
		completeStop(1000);

		//leave the room
		while(SensorValue[frontUltra]>25){
			walkStraight();
		}
				completeStop(1000);//exit the room


		//make 90 left turn
		turnLeft(90,comSpd);
		completeStop(1000);

		while(SensorValue[rightUltra]<rightSpace){
		walkStraight();// move to center of the hallways
}
		delayStop(400);
		completeStop(500);

		turnRight(90,comSpd);

		completeStop(500);

		while(SensorValue[frontUltra]>15){
			walkStraight();
		}

		completeStop(500);

		turnRight(90,comSpd);

		while(SensorValue[frontUltra]>30){   //Gets us into room 3
			walkStraight();
		}

		completeStop(500);


		turnRight(180,comSpd);


		while(SensorValue[frontUltra]>15){  //Gets us into room 4
		walkStraight();
	}


		completeStop(500);


		turnLeft(180,comSpd);

		turnRight(90,comSpd);

		while(SensorValue[frontUltra]>15){  //Gets near room 2
			walkStraight();
		}

		completeStop(500);








}
