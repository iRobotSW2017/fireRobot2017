#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  ultraFront,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  ultraLeft,      sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  ultraRight,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void Pointturn(int leftSpeed, int rightSpeed, int waittime){
	motor(rightMotor)=rightSpeed;
	motor(leftMotor)=leftSpeed;
	wait1Msec(490);
}
void completeStop(int delay){
		wait1Msec(delay); // allow the car to move forward until the body face open
		motor[rightMotor] = 0;
		motor[leftMotor]  = 0;
}
	void walkStraight(){
//while(SensorValue[ultrain]>10){
	if ((nMotorEncoder[rightMotor]) > (abs(nMotorEncoder[leftMotor]))){
		motor[rightMotor] = 40;
		motor[leftMotor] = 63;
	}

	if (nMotorEncoder[rightMotor] < abs(nMotorEncoder[leftMotor])){
		motor[rightMotor] = 63;
		motor[leftMotor] = 40;
	}
	if (nMotorEncoder[rightMotor] == abs(nMotorEncoder[leftMotor])){
		motor[rightMotor] = 63;
		motor[leftMotor] = 63;
	}
//}
}



task main()
{

wait1Msec(2000);


 while(SensorValue[ultraRight]<23){
   walkStraight();

}

completeStop(100);

	wait1Msec(500);


	Pointturn(60,-60,900);

	wait1Msec(500);

while(SensorValue[ultraFront]>20){
	walkStraight();
}
	completeStop(100);

	Pointturn(60,-60,900);

	while(SensorValue[ultraFront]>20){
	walkStraight();
}
	completeStop(100);

  Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);


while(SensorValue[ultraFront]>10) {
	walkStraight();
}
	completeStop(0);


	wait1Msec(500);


Pointturn(-60,60,900);

wait1Msec(500);

while(SensorValue[ultraRight]<23){
	walkStraight();
}

	completeStop(100);

	wait1Msec(500);

	Pointturn(60,-60,900);

	wait1Msec(500);

	while(SensorValue[ultraRight]<23){
		walkStraight();
	}

	completeStop(100);

	wait1Msec(500);

	Pointturn(60,-60,900);

	wait1Msec(500);

	while(SensorValue[ultraFront]>30){
		walkStraight();
	}

	completeStop(0);

	  Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);
Pointturn(90,-90,660);

completeStop(0);

wait1Msec(500);

	while(SensorValue[ultraFront]>10){
		walkStraight();
	}

	completeStop(0);

	wait1Msec(500);

		while(SensorValue[ultraFront]>15){
		walkStraight();
	}

	completeStop(100);

	Pointturn(-60,60,900);

	wait1Msec(500);

	walkStraight();

	wait1Msec(150);

	completeStop(0);

	Pointturn(-60,60,900);

	wait1Msec(500);

		while(SensorValue[ultraFront]>15){
		walkStraight();
	}

	completeStop(0);

	wait1Msec(500);

	Pointturn(90,-90,660);
	Pointturn(90,-90,660);
	Pointturn(90,-90,660);
	Pointturn(90,-90,660);
	Pointturn(90,-90,660);
	Pointturn(90,-90,660);

	while(SensorValue[ultraFront]>12){
		walkStraight();
	}

	completeStop(0);


	Pointturn(-60,60,900);

	while(SensorValue[ultraFront]>15){
		walkStraight();
	}

	completeStop(0);

	Pointturn(-60,60,900);

	completeStop(0);   // End back at the beginning



	}
