#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    IR_sensor,      sensorAnalog)
#pragma config(Sensor, dgtl3,  frontUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftUltra,      sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  rightUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  Bumpey,         sensorTouch)
#pragma config(Sensor, dgtl10, fan,            sensorDigitalOut)
#pragma config(Sensor, dgtl12, redLed,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//global variables
		//int comSpd = 90;
		//int lowSpd = 70;
		int comSpd = 50;
		int lowSpd = 40;
		int rightTicks = 41; //60
		int leftTicks = 42;	//57
		int turnSpd = 50;
		float halfSec50dist = 15.4;
		//int comAdjSpd = 31;
		//int delaySec = 450;
		//int frontSpace = 12; //(46-30)/2
		int rightSpace = 23;
		int flameDetected = 120;	//250
		int flameTargetAdj = 0; // 8
		int flameOff = 100;
		bool isFlameDetected = false;
		bool isFlameOff = false;

void resetEncoders(){
	nMotorEncoder[rightMotor]=0;
	nMotorEncoder[leftMotor]=0;
}

int turnLeft(int degrees, int speed, int offset){
	//you must reset the encoders
	resetEncoders();

	int tickGoal = ((leftTicks * degrees)/10 - offset);	//increased the tick goal by 1 today by mattyboio == 74@matt

	motor[rightMotor]=speed;
	motor[leftMotor]=-1*speed;

	while(nMotorEncoder[rightMotor]<tickGoal||nMotorEncoder[leftMotor]>-1*tickGoal){
		if(nMotorEncoder[rightMotor]>tickGoal){
			motor[rightMotor]=0;
		}
		if(nMotorEncoder[leftMotor]<-1*tickGoal){
			motor[leftMotor]=0;
		}
	}
	return abs(nMotorEncoder[leftMotor]);	//meaning turn is
}


task main()
{


		SensorValue[redLed] = 1; // turn off LED by default

		//wait to have a full stop
		while(SensorValue[Bumpey]==0){
			motor[leftMotor]=0;
			motor[rightMotor]=0;
		}
		wait1Msec(500);

		motor[rightMotor]=0;
		motor[leftMotor]=0;
		int _right0 = SensorValue[rightUltra];
		motor[rightMotor]=turnSpd;
		motor[leftMotor]=turnSpd;
		wait1Msec(500);
		int _right1 = SensorValue[rightUltra];
		//fat _result = asin(abs(_right0-_right1)/halfSec50dist);
		int _results = asin(abs(_right0-_right1)/halfSec50dist) * 180 / 3.1415;
		writeDebugStreamLine("degrees %d", _results);

			turnLeft(_results, turnSpd, 0);

			motor[leftMotor]=0;
			motor[rightMotor]=0;

}
