#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  frontUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftUltra,      sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  rightUltra,     sensorSONAR_cm)
#pragma config(Sensor, dgtl12, redLed,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void driveStraightWRightUltraSonic(int distance, int masterPower){
	int slavePower = masterPower - 20;
	int error = 0;
	int kp = 10;	// constant of proportionality -- kp;

	//reset encoders
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	while (SensorValue[rightUltra] <= distance){
		//proportional algorithm to keep robot going straight
		motor[rightMotor] = slavePower;
		motor[leftMotor] = masterPower;

		error = abs(nMotorEncoder[leftMotor]) - nMotorEncoder[rightMotor];

		slavePower += (error / kp);

		//reset encoders
		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;

		//wait1Msec(100);
	}

	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void checkTicks(int sec){
	int masterPower = 60;
	int slavePower = masterPower;
	int error = 0;
	int kp = 25;	// constant of proportionality -- kp;
 	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	int _total = 0;

	while (_total < sec){
		//proportional algorithm to keep robot going straight
		motor[leftMotor] = masterPower;
		motor[rightMotor] = slavePower;

		error = abs(nMotorEncoder[leftMotor]) - nMotorEncoder[rightMotor];

		slavePower += (error / kp);
		writeDebugStreamLine("RPM: %d", slavePower);

		//reset encoders
		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;

		wait1Msec(100);
		_total += 100;
	}
}

task main()
{

	SensorValue[redLed] = 1; //make sure RED-LED is off
int error = 0;
	wait1Msec(2000);

	//move along with the wall, stop when it is open on right side
	//driveStraightWRightUltraSonic(23, 60);
	//SensorValue[redLed] = 0;

	int _total = 0;

		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;

		while (_total < 1000){
		//proportional algorithm to keep robot going straight
		motor[leftMotor] = 60;
		motor[rightMotor] = 60;

		error = abs(nMotorEncoder[leftMotor]) - nMotorEncoder[rightMotor];
		writeDebugStreamLine("error: %d", error);

		//reset encoders
		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;

		_total += 100;
		wait1Msec(100);
	}
}
